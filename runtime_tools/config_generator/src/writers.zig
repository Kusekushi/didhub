const std = @import("std");
const config = @import("config.zig");

pub const GenError = error{InvalidFormat};

// ============================================================================
// Format-specific writers
// ============================================================================

const FormatWriter = struct {
    file: std.fs.File,
    writer: @TypeOf(std.fs.File.stdout().deprecatedWriter()),
    format: Format,

    const Format = enum { json, toml, yaml };

    fn init(out_path: []const u8, format: Format) !FormatWriter {
        var file = try std.fs.cwd().createFile(out_path, .{ .truncate = true });
        return .{ .file = file, .writer = file.deprecatedWriter(), .format = format };
    }

    fn deinit(self: *FormatWriter) void {
        self.file.close();
    }

    // Write document header
    fn writeHeader(self: *FormatWriter) !void {
        switch (self.format) {
            .json => try self.file.writeAll("{\n"),
            .toml => try self.writer.writeAll("# This file was generated by config-generator.\n# Edit values to suit your environment; environment variables (DIDHUB_*) take precedence.\n\n"),
            .yaml => try self.writer.writeAll("# This file was generated by config-generator.\n"),
        }
    }

    // Write document footer
    fn writeFooter(self: *FormatWriter) !void {
        if (self.format == .json) try self.file.writeAll("}\n");
    }

    // Write section start
    fn writeSection(self: *FormatWriter, name: []const u8) !void {
        switch (self.format) {
            .json => try std.fmt.format(self.writer, "  \"{s}\": {{\n", .{name}),
            .toml => try std.fmt.format(self.writer, "[{s}]\n", .{name}),
            .yaml => try std.fmt.format(self.writer, "{s}:\n", .{name}),
        }
    }

    // Write section end
    fn endSection(self: *FormatWriter, trailing_comma: bool) !void {
        switch (self.format) {
            .json => try self.file.writeAll(if (trailing_comma) "  },\n" else "  }\n"),
            .toml => try self.file.writeAll("\n"),
            .yaml => {},
        }
    }

    // Write a string field
    fn writeStr(self: *FormatWriter, key: []const u8, value: []const u8, trailing: bool) !void {
        switch (self.format) {
            .json => try std.fmt.format(self.writer, "    \"{s}\": \"{s}\"{s}\n", .{ key, value, if (trailing) "," else "" }),
            .toml => try std.fmt.format(self.writer, "{s} = \"{s}\"\n", .{ key, value }),
            .yaml => try std.fmt.format(self.writer, "  {s}: {s}\n", .{ key, value }),
        }
    }

    // Write an optional string field
    fn writeOptStr(self: *FormatWriter, key: []const u8, value: ?[]const u8, trailing: bool) !void {
        if (value) |v| {
            try self.writeStr(key, v, trailing);
        } else {
            switch (self.format) {
                .json => try std.fmt.format(self.writer, "    \"{s}\": null{s}\n", .{ key, if (trailing) "," else "" }),
                .toml => {}, // TOML omits null values
                .yaml => {}, // YAML omits null values
            }
        }
    }

    // Write an integer field
    fn writeInt(self: *FormatWriter, key: []const u8, value: anytype, trailing: bool) !void {
        switch (self.format) {
            .json => try std.fmt.format(self.writer, "    \"{s}\": {d}{s}\n", .{ key, value, if (trailing) "," else "" }),
            .toml => try std.fmt.format(self.writer, "{s} = {d}\n", .{ key, value }),
            .yaml => try std.fmt.format(self.writer, "  {s}: {d}\n", .{ key, value }),
        }
    }

    // Write an optional integer field
    fn writeOptInt(self: *FormatWriter, key: []const u8, value: anytype, trailing: bool) !void {
        if (value) |v| {
            try self.writeInt(key, v, trailing);
        } else {
            switch (self.format) {
                .json => try std.fmt.format(self.writer, "    \"{s}\": null{s}\n", .{ key, if (trailing) "," else "" }),
                .toml => {},
                .yaml => {},
            }
        }
    }

    // Write a boolean field
    fn writeBool(self: *FormatWriter, key: []const u8, value: bool, trailing: bool) !void {
        const v = if (value) "true" else "false";
        switch (self.format) {
            .json => try std.fmt.format(self.writer, "    \"{s}\": {s}{s}\n", .{ key, v, if (trailing) "," else "" }),
            .toml => try std.fmt.format(self.writer, "{s} = {s}\n", .{ key, v }),
            .yaml => try std.fmt.format(self.writer, "  {s}: {s}\n", .{ key, v }),
        }
    }

    // Write a string array field
    fn writeStrArray(self: *FormatWriter, key: []const u8, items: []const []const u8, trailing: bool) !void {
        switch (self.format) {
            .json => {
                try std.fmt.format(self.writer, "    \"{s}\": [", .{key});
                for (items, 0..) |item, i| {
                    if (i > 0) try self.file.writeAll(", ");
                    try std.fmt.format(self.writer, "\"{s}\"", .{item});
                }
                try self.file.writeAll(if (trailing) "],\n" else "]\n");
            },
            .toml => {
                try std.fmt.format(self.writer, "{s} = [", .{key});
                for (items, 0..) |item, i| {
                    if (i > 0) try self.file.writeAll(", ");
                    try std.fmt.format(self.writer, "\"{s}\"", .{item});
                }
                try self.file.writeAll("]\n");
            },
            .yaml => {
                try std.fmt.format(self.writer, "  {s}:\n", .{key});
                for (items) |item| try std.fmt.format(self.writer, "    - {s}\n", .{item});
            },
        }
    }

    // Write a top-level optional string (for redis_url)
    fn writeTopLevelOptStr(self: *FormatWriter, key: []const u8, value: ?[]const u8) !void {
        if (value) |v| {
            switch (self.format) {
                .json => try std.fmt.format(self.writer, "  \"{s}\": \"{s}\",\n", .{ key, v }),
                .toml => try std.fmt.format(self.writer, "{s} = \"{s}\"\n\n", .{ key, v }),
                .yaml => try std.fmt.format(self.writer, "{s}: {s}\n", .{ key, v }),
            }
        } else if (self.format == .json) {
            try std.fmt.format(self.writer, "  \"{s}\": null,\n", .{key});
        }
    }
};

// ============================================================================
// Public API
// ============================================================================

pub fn write_config(cfg: *config.Config, fmt: []const u8, out_path: []const u8) !void {
    const format: FormatWriter.Format = if (std.mem.eql(u8, fmt, "json"))
        .json
    else if (std.mem.eql(u8, fmt, "toml"))
        .toml
    else if (std.mem.eql(u8, fmt, "yaml") or std.mem.eql(u8, fmt, "yml"))
        .yaml
    else
        return GenError.InvalidFormat;

    var fw = try FormatWriter.init(out_path, format);
    defer fw.deinit();

    try fw.writeHeader();

    // Server
    try fw.writeSection("server");
    try fw.writeStr("host", cfg.server.host, true);
    try fw.writeInt("port", cfg.server.port, false);
    try fw.endSection(true);

    // Logging
    try fw.writeSection("logging");
    try fw.writeStr("level", cfg.logging.level, true);
    try fw.writeBool("json", cfg.logging.json, false);
    try fw.endSection(true);

    // CORS
    try fw.writeSection("cors");
    try fw.writeStrArray("allowed_origins", cfg.cors.allowed_origins.items, true);
    try fw.writeBool("allow_all_origins", cfg.cors.allow_all_origins, false);
    try fw.endSection(true);

    // Redis URL (top-level)
    try fw.writeTopLevelOptStr("redis_url", cfg.redis_url);

    // Database
    try fw.writeSection("database");
    try fw.writeStr("driver", cfg.database.driver, true);
    try fw.writeOptStr("path", cfg.database.path, true);
    if (!cfg.database.isSqlite()) {
        try fw.writeOptStr("host", cfg.database.host, true);
        try fw.writeOptInt("port", cfg.database.port, true);
        try fw.writeOptStr("database", cfg.database.database, true);
    } else if (format == .json) {
        // JSON needs explicit nulls for consistency
        try fw.writeOptStr("host", null, true);
        try fw.writeOptInt("port", @as(?u16, null), true);
        try fw.writeOptStr("database", null, true);
    }
    try fw.writeOptStr("username", cfg.database.username, true);
    try fw.writeOptStr("password", cfg.database.password, true);
    try fw.writeOptStr("ssl_mode", cfg.database.ssl_mode, false);
    try fw.endSection(true);

    // Uploads
    try fw.writeSection("uploads");
    try fw.writeStr("directory", cfg.uploads.directory, false);
    try fw.endSection(true);

    // Auto Update
    try fw.writeSection("auto_update");
    try fw.writeBool("enabled", cfg.auto_update.enabled, true);
    try fw.writeBool("check_enabled", cfg.auto_update.check_enabled, true);
    try fw.writeOptStr("repo", cfg.auto_update.repo, true);
    try fw.writeInt("check_interval_hours", cfg.auto_update.check_interval_hours, false);
    try fw.endSection(true);

    // Rate Limit
    try fw.writeSection("rate_limit");
    try fw.writeBool("enabled", cfg.rate_limit.enabled, true);
    try fw.writeBool("per_ip", cfg.rate_limit.per_ip, true);
    try fw.writeBool("per_user", cfg.rate_limit.per_user, true);
    try fw.writeInt("rate_per_sec", cfg.rate_limit.rate_per_sec, true);
    try fw.writeInt("burst", cfg.rate_limit.burst, true);
    try fw.writeStrArray("exempt_paths", cfg.rate_limit.exempt_paths.items, false);
    try fw.endSection(true);

    // Auth
    try fw.writeSection("auth");
    try fw.writeOptStr("jwt_pem", cfg.auth.jwt_pem, true);
    try fw.writeOptStr("jwt_pem_path", cfg.auth.jwt_pem_path, true);
    try fw.writeOptStr("jwt_secret", cfg.auth.jwt_secret, false);
    try fw.endSection(false);

    try fw.writeFooter();
}
