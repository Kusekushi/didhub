// Auto-generated by build_tools/api_codegen. Do not edit manually.
/* eslint-disable @typescript-eslint/no-explicit-any */

import type * as Types from './types';

export type QueryValue = string | number | boolean | null | undefined;

export interface ApiRequestOptions {
  path?: Record<string, unknown>;
  query?: Record<string, QueryValue | QueryValue[]>;
  body?: unknown;
  headers?: Record<string, string>;
  signal?: AbortSignal;
}

export interface ApiResponse<T = unknown> {
  status: number;
  data: T;
  headers: Headers;
}

export class ApiClient {
  constructor(
    private readonly baseUrl: string = '',
    private readonly defaultHeaders: Record<string, string> = {},
  ) {}

  {% for op in operations %}
  /** {{ op.summary | default('') }} */
  async {{ op.method_name }}<T = {{ op.ts_return_type }}>(options: ApiRequestOptions = {}): Promise<ApiResponse<T>> {
    return this.request<T>('{{ op.method | upper }}', '{{ op.path }}', {{ 'true' if op.has_body else 'false' }}, options);
  }

  {% endfor %}
  async request<T>(method: string, pathTemplate: string, expectsBody: boolean, options: ApiRequestOptions): Promise<ApiResponse<T>> {
    const path = this.interpolatePath(pathTemplate, options.path);
    let url = this.normalizeBaseUrl() + path;

    if (options.query) {
      const queryString = this.encodeQuery(options.query);
      if (queryString) {
        url += (url.includes('?') ? '&' : '?') + queryString;
      }
    }

    const headers = new Headers({ ...this.defaultHeaders, ...options.headers });
    const init: RequestInit = {
      method,
      headers,
      signal: options.signal,
      credentials: 'include',
    };

    // Automatically fetch and include CSRF token for unsafe methods
    if (this.methodAllowsPayload(method) && !headers.has('x-csrf-token')) {
      try {
        const csrfToken = await this.fetchCsrfToken();
        headers.set('x-csrf-token', csrfToken);
      } catch (error) {
        // If CSRF token fetch fails, continue without it
        // The request might still work if the endpoint doesn't require CSRF
        console.warn('Failed to fetch CSRF token:', error);
      }
    }

    if (options.body !== undefined && (expectsBody || this.methodAllowsPayload(method))) {
      if (!headers.has('content-type')) {
        headers.set('content-type', 'application/json');
      }
      init.body = JSON.stringify(options.body);
    }

    const response = await fetch(url, init);
    return this.parseResponse<T>(response);
  }

  private normalizeBaseUrl(): string {
    if (!this.baseUrl) {
      return '';
    }
  return this.baseUrl.endsWith('/') ? this.baseUrl.slice(0, -1) : this.baseUrl;
  }

  private interpolatePath(template: string, params: Record<string, unknown> | undefined): string {
    return template.replace(/\{([^}]+)\}/g, (_match, key) => {
      const value = params?.[key];
      if (value === undefined || value === null) {
        throw new Error(`Missing value for path parameter "${key}" in template "${template}"`);
      }
      return encodeURIComponent(String(value));
    });
  }

  private encodeQuery(query: Record<string, QueryValue | QueryValue[]>): string {
    const entries: string[] = [];
    for (const [key, rawValue] of Object.entries(query)) {
      if (rawValue === undefined) {
        continue;
      }
      const values = Array.isArray(rawValue) ? rawValue : [rawValue];
      for (const value of values) {
        if (value === undefined || value === null) {
          continue;
        }
        entries.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);
      }
    }
    return entries.join('&');
  }

  private methodAllowsPayload(method: string): boolean {
    switch (method.toUpperCase()) {
      case 'POST':
      case 'PUT':
      case 'PATCH':
      case 'DELETE':
        return true;
      default:
        return false;
    }
  }

  private async parseResponse<T>(response: Response): Promise<ApiResponse<T>> {
    const contentType = response.headers.get('content-type') || '';
    let data: any = null;

    if (contentType.includes('application/json')) {
      data = await response.json();
    } else if (contentType.startsWith('text/')) {
      data = (await response.text()) as any;
    } else if (contentType) {
      data = await response.arrayBuffer();
    }

    if (!response.ok) {
      // If the server returned a structured validation payload, throw a typed ValidationError
      if (response.status === 400 && data && typeof data === 'object' && Object.prototype.hasOwnProperty.call(data, 'validation')) {
        throw new ValidationError(response.status, data as Types.ValidationPayload);
      }
      throw new ApiError(response.status, data ?? { error: 'Request failed' });
    }

    return {
      status: response.status,
      data: data as T,
      headers: response.headers,
    };
  }

  /** Fetch CSRF token for authenticated requests */
  async fetchCsrfToken(): Promise<string> {
    // First, ensure the CSRF token cookie is set by calling the endpoint
    await this.request<{ token: string }>('GET', '/csrf-token', false, {});
    
    // Then read the token from the cookie (double-submit cookie pattern)
    const cookies = document.cookie.split(';');
    for (const cookie of cookies) {
      const [name, value] = cookie.trim().split('=');
      if (name === 'csrf_token') {
        return decodeURIComponent(value);
      }
    }
    
    throw new Error('CSRF token cookie not found after fetching');
  }
}

export class ApiError extends Error {
  constructor(public readonly status: number, public readonly payload: unknown) {
    super(`Request failed with status ${status}`);
  }
}

// Represents the structured validation payload produced by the backend
// Note: ValidationIssue and ValidationPayload are defined in types.ts

export class ValidationError extends ApiError {
  declare payload: Types.ValidationPayload;
  constructor(status: number, payload: Types.ValidationPayload) {
    super(status, payload);
    this.name = 'ValidationError';
  }
}

// Type guard helper: narrow ApiError to ValidationError when appropriate
export function isValidationError(err: unknown): err is ValidationError {
  if (!err || typeof err !== 'object') return false;
  const e = err as any;
  return e instanceof ValidationError || (e && typeof e.status === 'number' && e.payload && typeof e.payload === 'object' && 'validation' in e.payload);
}
