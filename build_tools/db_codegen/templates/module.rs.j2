// Auto-generated by db_codegen. Do not edit by hand.
#![allow(clippy::all, missing_docs, dead_code, unused_imports)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use crate::DbBackend;
use serde::{Deserialize, Serialize};
use sqlx::Executor;

{% if aliases %}{% for alias in aliases %}#[cfg(feature = "uuid-native")]
type {{ alias.name }} = {{ alias.native }};
#[cfg(not(feature = "uuid-native"))]
type {{ alias.name }} = {{ alias.fallback }};

{% endfor %}{% endif %}#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct {{ struct_name }} {
{% for column in columns %}    pub {{ column.field_name }}: {{ column.field_type }},
{% endfor %}}

pub const TABLE_NAME: &str = {{ table_name_literal }};
pub const COLUMN_NAMES: [&str; {{ columns|length }}] = [{{ column_names_literal }}];
pub const COLUMN_LIST: &str = {{ column_list_literal }};
pub const SELECT_ALL: &str = {{ select_all_literal }};
{% if has_primary_key %}pub const SELECT_BY_PRIMARY_KEY: &str = {{ select_by_pk_literal }};
pub const DELETE_BY_PRIMARY_KEY: &str = {{ delete_by_pk_literal }};
{% endif %}
pub const INSERT_ROW: &str = {{ insert_literal }};
{% if has_update_by_pk %}pub const UPDATE_BY_PRIMARY_KEY: &str = {{ update_by_pk_literal }};
{% endif %}
pub async fn list_all<'e, E>(executor: E) -> Result<Vec<{{ struct_name }}>, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    sqlx::query_as::<_, {{ struct_name }}>(SELECT_ALL).fetch_all(executor).await
}
{% if has_primary_key %}
pub async fn find_by_primary_key<'e, E>(
    executor: E,
    key: &{{ pk_column.resolved_base_type }},
) -> Result<Option<{{ struct_name }}>, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    sqlx::query_as::<_, {{ struct_name }}>(SELECT_BY_PRIMARY_KEY)
        .bind(key)
        .fetch_optional(executor)
        .await
}

pub async fn delete_by_primary_key<'e, E>(
    executor: E,
    key: &{{ pk_column.resolved_base_type }},
) -> Result<u64, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    let result = sqlx::query(DELETE_BY_PRIMARY_KEY)
        .bind(key)
        .execute(executor)
        .await?;
    Ok(result.rows_affected())
}
{% endif %}

pub async fn insert_row<'e, E>(executor: E, row: &{{ struct_name }}) -> Result<u64, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    let result = sqlx::query(INSERT_ROW)
{% for column in columns %}        .bind({% if column.is_nullable %}row.{{ column.field_name }}.clone(){% else %}&row.{{ column.field_name }}{% endif %})
{% endfor %}
        .execute(executor)
        .await?;
    Ok(result.rows_affected())
}

{% if insert_alias_distinct %}pub async fn {{ insert_function_name }}<'e, E>(executor: E, row: &{{ struct_name }}) -> Result<u64, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    insert_row(executor, row).await
}

{% endif %}{% if has_update_by_pk %}pub async fn update_by_primary_key<'e, E>(
    executor: E,
    key: &{{ pk_column.resolved_base_type }},
    row: &{{ struct_name }},
) -> Result<u64, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    let result = sqlx::query(UPDATE_BY_PRIMARY_KEY)
{% for column in updatable_columns %}        .bind({% if column.is_nullable %}row.{{ column.field_name }}.clone(){% else %}&row.{{ column.field_name }}{% endif %})
{% endfor %}
        .bind(key)
        .execute(executor)
        .await?;
    Ok(result.rows_affected())
}
{% endif %}
{% for method in finder_methods %}
{% if method.column %}
pub async fn {{ method.name }}<'e, E>(
    executor: E,
    value: &{{ method.column.resolved_base_type }},
) -> Result<Vec<{{ struct_name }}>, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    sqlx::query_as::<_, {{ struct_name }}>({{ method.select_sql }})
        .bind(value)
        .fetch_all(executor)
        .await
}

pub async fn {{ method.name|replace("find_by_", "find_first_by_") }}<'e, E>(
    executor: E,
    value: &{{ method.column.resolved_base_type }},
) -> Result<Option<{{ struct_name }}>, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    sqlx::query_as::<_, {{ struct_name }}>({{ method.select_sql }})
        .bind(value)
        .fetch_optional(executor)
        .await
}
{% else %}
pub async fn {{ method.name }}<'e, E>(executor: E) -> Result<Vec<{{ struct_name }}>, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    sqlx::query_as::<_, {{ struct_name }}>({{ method.select_sql }})
        .fetch_all(executor)
        .await
}
{% endif %}
{% endfor %}
{% if finder_methods %}
// Repository methods for common query patterns
{% if has_created_at_index %}
pub async fn list_ordered_by_created_at_desc<'e, E>(executor: E) -> Result<Vec<{{ struct_name }}>, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    sqlx::query_as::<_, {{ struct_name }}>({{ select_ordered_by_created_at_desc }})
        .fetch_all(executor)
        .await
}

pub async fn list_paginated_ordered_by_created_at_desc<'e, E>(
    executor: E,
    limit: i64,
    offset: i64,
) -> Result<Vec<{{ struct_name }}>, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    sqlx::query_as::<_, {{ struct_name }}>({{ select_paginated_ordered_by_created_at_desc }})
        .bind(limit)
        .bind(offset)
        .fetch_all(executor)
        .await
}
{% endif %}
{% if has_name_index %}
pub async fn list_ordered_by_name<'e, E>(executor: E) -> Result<Vec<{{ struct_name }}>, sqlx::Error>
where
    E: Executor<'e, Database = DbBackend>,
{
    sqlx::query_as::<_, {{ struct_name }}>({{ select_ordered_by_name }})
        .fetch_all(executor)
        .await
}
{% endif %}
{% endif %}
